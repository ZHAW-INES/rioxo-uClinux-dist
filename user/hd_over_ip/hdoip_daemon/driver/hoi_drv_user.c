/*
 * hoi_drv_user.c
 * This function do no range testing!
 *
 *  Created on: 18.10.2010
 *      Author: alda
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "hdoipd.h"
#include "hoi_drv_user.h"
#include "version.h"
#include "edid_merge.h"

#include "usb.h"

#include <netdb.h>
extern int h_errno;


int hoi_msg(void* param)
{
    int ret;
    if ((ret = ioctl(hdoipd.drv, HDOIP_IOCPARAM, param))) {
        perrno("hoi_msg(%d, %08x:%d Byte) failed = %d", hdoipd.drv, *(uint32_t*)param, ((uint32_t*)param)[1], ret);
    }
    return ret;
}


//------------------------------------------------------------------------------
// additional driver load/unload command

int hoi_drv_ldrv(uint32_t drivers)
{
    t_hoi_msg_ldrv msg;

    hoi_msg_ldrv_init(&msg);
    msg.drivers = drivers;

    return hoi_msg(&msg);
}

int hoi_drv_buf(void* ar, size_t arl, void* vr, size_t vrl, void* at, size_t atl, void* vt, size_t vtl)
{
    t_hoi_msg_buf msg;

    hoi_msg_buf_init(&msg);
    msg.aud_rx_buf = ar; msg.aud_rx_len = arl; memset(ar, 0, arl);
    msg.vid_rx_buf = vr; msg.vid_rx_len = vrl; memset(vr, 0, vrl);
    msg.aud_tx_buf = at; msg.aud_tx_len = atl; memset(at, 0, atl);
    msg.vid_tx_buf = vt; msg.vid_tx_len = vtl; memset(vt, 0, vtl);

    return hoi_msg(&msg);
}
//-----------------------------------------------------------------------------
// HDCP
//send hdcp keys to kernel
int hoi_drv_hdcp(uint32_t* hdcp_keys)
{
    t_hoi_msg_hdcp_init msg;

    hoi_msg_hdcp_init(&msg);
    msg.key0 = hdcp_keys[0];
    msg.key1 = hdcp_keys[1];
    msg.key2 = hdcp_keys[2];
    msg.key3 = hdcp_keys[3];
    msg.riv0 = hdcp_keys[4];
    msg.riv1 = hdcp_keys[5];

    return hoi_msg(&msg);
}

//get hdcp status
int hoi_drv_hdcpstat(uint32_t *eto_hdcp_audio,uint32_t *eto_hdcp_video,uint32_t *eti_hdcp_audio, uint32_t *eti_hdcp_video)
{
    int ret;
    t_hoi_msg_hdcpstat msg;

    hoi_msg_hdcpstat_init(&msg);
    ret = hoi_msg(&msg);
    *eto_hdcp_audio = msg.status_eto_audio;
    *eto_hdcp_video = msg.status_eto_video;
    *eti_hdcp_audio = msg.status_eti_audio;
    *eti_hdcp_video = msg.status_eti_video;

    return ret;
}
//-----------------------------------------------------------------------------

int hoi_drv_eti(uint32_t addr_dst, uint32_t addr_src_vid, uint32_t addr_src_aud, uint32_t vid, uint32_t aud)
{
    t_hoi_msg_eti msg;

    hoi_msg_eti_init(&msg);
    msg.ip_address_dst = addr_dst;
    msg.ip_address_src_vid = addr_src_vid;
    msg.ip_address_src_aud = addr_src_aud;
    msg.udp_port_aud = aud;
    msg.udp_port_vid = vid;

    return hoi_msg(&msg);

}

int hoi_drv_info(t_video_timing* timing, uint32_t *advcnt)
{
    int ret;
    t_hoi_msg_info msg;

    hoi_msg_info_init(&msg);
    msg.advcnt = 0;
    if (advcnt) msg.advcnt = *advcnt;
    ret = hoi_msg(&msg);
    if (advcnt) *advcnt = msg.advcnt;
    memcpy(timing, &msg.timing, sizeof(t_video_timing));

    return ret;
}

int hoi_drv_info_all(t_hoi_msg_info** nfo)
{
    int ret;
    static t_hoi_msg_info msg;

    hoi_msg_info_init(&msg);
    msg.advcnt = 0;
    ret = hoi_msg(&msg);
    *nfo = &msg;

    return ret;
}

#define HOI_GET_STAT(T)                         \
    int hoi_drv_##T(t_hoi_msg_##T **stat)       \
    {                                           \
        int ret;                                \
        static t_hoi_msg_##T msg;               \
        hoi_msg_##T##_init(&msg);               \
        ret = hoi_msg(&msg);                    \
        if (stat) *stat = &msg;                 \
        return ret;                             \
    }

HOI_GET_STAT(vsostat);
HOI_GET_STAT(ethstat);
HOI_GET_STAT(viostat);
HOI_GET_STAT(asoreg);

//------------------------------------------------------------------------------
// setup/read video format for input/output

#define HOI_WRITE(T, L)                         \
    int hoi_drv_##T(uint32_t p)                 \
    {                                           \
        t_hoi_msg_param msg;                    \
        hoi_msg_write_init(&msg, L);            \
        msg.value = p;                          \
        return hoi_msg(&msg);                   \
    }

#define HOI_READ(T, L)                          \
    int hoi_drv_##T(uint32_t *p)                \
    {                                           \
        int ret;                                \
        t_hoi_msg_param msg;                    \
        hoi_msg_read_init(&msg, L);             \
        ret = hoi_msg(&msg);                    \
        *p = msg.value;                         \
        return ret;                             \
    }

HOI_WRITE(ifmt, HOI_MSG_IFMT);
HOI_WRITE(ofmt, HOI_MSG_OFMT);
HOI_WRITE(pfmt, HOI_MSG_PFMT);
HOI_WRITE(set_mtime, HOI_MSG_SETMTIME);
HOI_WRITE(set_stime, HOI_MSG_SETSTIME);
HOI_WRITE(timer, HOI_MSG_TIMER);
HOI_WRITE(set_led_status, HOI_MSG_LED);
HOI_WRITE(reset, HOI_MSG_OFF);
HOI_WRITE(new_audio, HOI_MSG_NEW_AUDIO);
HOI_WRITE(read_ram, HOI_MSG_DEBUG_READ_RAM);
HOI_WRITE(set_fps_reduction, HOI_MSG_SET_FPS_REDUCTION);

HOI_READ(get_mtime, HOI_MSG_GETMTIME);
HOI_READ(get_stime, HOI_MSG_GETSTIME);
HOI_READ(get_syncdelay, HOI_MSG_SYNCDELAY);
HOI_READ(get_fs, HOI_MSG_GET_FS);
HOI_READ(get_analog_timing, HOI_MSG_GET_ANALOG_TIMING);
HOI_READ(get_device_id, HOI_MSG_GET_DEV_ID);
HOI_READ(get_reset_to_default, HOI_MSG_GET_RESET_TO_DEFAULT);
HOI_READ(get_encrypted_status, HOI_MSG_GET_ENCRYPTED_STATUS);

//------------------------------------------------------------------------------
// capture/show image command

int hoi_drv_vsi(uint32_t compress, uint32_t encrypt, int bandwidth, hdoip_eth_params* eth, t_video_timing* timing, uint32_t* advcnt)
{
    int ret;
    t_hoi_msg_vsi msg;

    hoi_msg_vsi_init(&msg);
    msg.bandwidth = bandwidth;
    msg.compress = compress;
    msg.encrypt = encrypt;
    if (advcnt) msg.advcnt = *advcnt;
    memcpy(&msg.eth, eth, sizeof(struct hdoip_eth_params));
    ret = hoi_msg(&msg);
    memcpy(timing, &msg.timing, sizeof(t_video_timing));
    if (advcnt) *advcnt = msg.advcnt;

    return ret;
}

int hoi_drv_vso(uint32_t compress, uint32_t encrypt, t_video_timing* timing, uint32_t advcnt, uint32_t delay_ms)
{
    int ret;
    t_hoi_msg_vso msg;

    hoi_msg_vso_init(&msg);
    msg.compress = compress;
    msg.advcnt = advcnt;
    msg.delay_ms = delay_ms;
    msg.encrypt = encrypt;
    memcpy(&msg.timing, timing, sizeof(t_video_timing));
    ret = hoi_msg(&msg);

    return ret;
}


int hoi_drv_asi(uint32_t cfg, hdoip_eth_params* eth, uint32_t fs, uint32_t width, uint32_t cnt, uint8_t* sel)
{
    int ret;
    t_hoi_msg_asi msg;

    hoi_msg_asi_init(&msg);
    msg.cfg = cfg;
    memcpy(&msg.channel, sel, 16);
    msg.channel_cnt = cnt;
    msg.fs = fs;
    msg.width = width;
    memcpy(&msg.eth, eth, sizeof(hdoip_eth_params));
    ret = hoi_msg(&msg);

    return ret;
}


int hoi_drv_aso(uint32_t fs, uint32_t fs_tol, uint32_t width, uint32_t cnt, uint8_t* sel, uint32_t delay_ms, uint32_t cfg)
{
    int ret;
    t_hoi_msg_aso msg;

    hoi_msg_aso_init(&msg);
    msg.cfg = cfg;
    msg.fs_tol = fs_tol;
    memcpy(&msg.channel, sel, 16);
    msg.channel_cnt = cnt;
    msg.fs = fs;
    msg.width = width;
    msg.delay_ms = delay_ms;
    ret = hoi_msg(&msg);

    return ret;
}


int hoi_drv_capture(bool compress, void* buffer, size_t size, t_video_timing* timing, uint32_t* advcnt)
{
    int ret;
    t_hoi_msg_image msg;

    hoi_msg_capture_init(&msg);
    msg.compress = compress;
    msg.buffer = buffer;
    msg.size = size;
    ret = hoi_msg(&msg);
    memcpy(timing, &msg.timing, sizeof(t_video_timing));
    if (compress && advcnt) *advcnt = msg.advcnt;

    return ret;
}

int hoi_drv_show(bool compress, void* buffer, t_video_timing* timing, uint32_t advcnt)
{
    int ret;
    t_hoi_msg_image msg;

    hoi_msg_show_init(&msg);
    msg.compress = compress;
    msg.buffer = buffer;
    memcpy(&msg.timing, timing, sizeof(t_video_timing));
    msg.advcnt = advcnt;
    ret = hoi_msg(&msg);

    return ret;
}

int hoi_drv_bw(uint32_t bw, uint32_t chroma)
{
    t_hoi_msg_bandwidth msg;
    hoi_msg_bandwidth_init(&msg);
    msg.bw = bw;
    msg.chroma = chroma;
    return hoi_msg(&msg);
}

/*
const uint8_t edid_hp2710m[256]=
{
0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
0x22,0xf0,0x94,0x28,0x01,0x01,0x01,0x01,
0x18,0x14,0x01,0x03,0x80,0x3c,0x22,0x78,
0x2e,0x60,0xe5,0xa9,0x51,0x35,0xab,0x24,
0x11,0x50,0x54,0xa1,0x08,0x00,0x81,0xc0,
0x81,0x40,0x81,0x80,0x95,0x00,0xa9,0x40,
0xb3,0x00,0xd1,0xc0,0x01,0x01,0x02,0x3a,
0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,
0x45,0x00,0x58,0x54,0x21,0x00,0x00,0x1e,
0x00,0x00,0x00,0xfd,0x00,0x32,0x4c,0x18,
0x5e,0x11,0x00,0x0a,0x20,0x20,0x20,0x20,
0x20,0x20,0x00,0x00,0x00,0xfc,0x00,0x48,
0x50,0x20,0x32,0x37,0x31,0x30,0x0a,0x20,
0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xff,
0x00,0x33,0x43,0x51,0x30,0x32,0x34,0x32,
0x48,0x37,0x5a,0x0a,0x20,0x20,0x01,0xd4,
0x02,0x03,0x23,0xf1,0x23,0x09,0x07,0x07,
0x49,0x84,0x02,0x03,0x01,0x11,0x12,0x10,
0x1f,0x13,0x83,0x01,0x00,0x00,0x6c,0x03,
0x0c,0x00,0x10,0x00,0xb8,0x2d,0xc0,0x01,
0x01,0x01,0x01,0x8c,0x0a,0xd0,0x8a,0x20,
0xe0,0x2d,0x10,0x10,0x3e,0x96,0x00,0x58,
0x54,0x21,0x00,0x00,0x18,0x8c,0x0a,0xd0,
0x90,0x20,0x40,0x31,0x20,0x0c,0x40,0x55,
0x00,0x58,0x54,0x21,0x00,0x00,0x18,0x01,
0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,0x6e,
0x28,0x55,0x00,0x58,0x54,0x21,0x00,0x00,
0x1e,0x01,0x1d,0x00,0xbc,0x52,0xd0,0x1e,
0x20,0xb8,0x28,0x55,0x40,0x58,0x54,0x21,
0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3b
};

const uint8_t edid_sony_bravia[256]=
{
0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
0x4d,0xd9,0x01,0xee,0x01,0x01,0x01,0x01,
0x01,0x14,0x01,0x03,0x80,0xa0,0x5a,0x78,
0x0a,0x0d,0xc9,0xa0,0x57,0x47,0x98,0x27,
0x12,0x48,0x4c,0x21,0x08,0x00,0x81,0x80,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x3a,
0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,
0x45,0x00,0x40,0x84,0x63,0x00,0x00,0x1e,
0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,
0x6e,0x28,0x55,0x00,0x40,0x84,0x63,0x00,
0x00,0x1e,0x00,0x00,0x00,0xfc,0x00,0x53,
0x4f,0x4e,0x59,0x20,0x54,0x56,0x0a,0x20,
0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xfd,
0x00,0x30,0x3e,0x0e,0x46,0x0f,0x00,0x0a,
0x20,0x20,0x20,0x20,0x20,0x20,0x01,0xbe,
0x02,0x03,0x2c,0xf0,0x50,0x1f,0x10,0x14,
0x05,0x13,0x04,0x12,0x11,0x16,0x15,0x03,
0x02,0x07,0x06,0x01,0x20,0x26,0x09,0x07,
0x07,0x15,0x07,0x50,0x83,0x01,0x00,0x00,
0x68,0x03,0x0c,0x00,0x10,0x00,0xb8,0x2d,
0x0f,0xe2,0x00,0x7b,0x02,0x3a,0x80,0xd0,
0x72,0x38,0x2d,0x40,0x10,0x2c,0x45,0x80,
0x40,0x84,0x63,0x00,0x00,0x1e,0x01,0x1d,
0x00,0xbc,0x52,0xd0,0x1e,0x20,0xb8,0x28,
0x55,0x40,0x40,0x84,0x63,0x00,0x00,0x1e,
0x01,0x1d,0x80,0x18,0x71,0x1c,0x16,0x20,
0x58,0x2c,0x25,0x00,0x40,0x84,0x63,0x00,
0x00,0x9e,0x01,0x1d,0x80,0xd0,0x72,0x1c,
0x16,0x20,0x10,0x2c,0x25,0x80,0x40,0x84,
0x63,0x00,0x00,0x9e,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e
};

const uint8_t edid_dell_1908fp[256]=
{
0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
0x10,0xac,0x26,0x40,0x4c,0x4d,0x34,0x31,
0x29,0x12,0x01,0x03,0x80,0x26,0x1e,0x78,
0x2e,0xee,0xa5,0xa3,0x54,0x4c,0x99,0x26,
0x14,0x50,0x54,0xa5,0x4b,0x00,0x71,0x4f,
0x81,0x80,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x30,0x2a,
0x00,0x98,0x51,0x00,0x2a,0x40,0x30,0x70,
0x13,0x00,0x78,0x2d,0x11,0x00,0x00,0x1e,
0x00,0x00,0x00,0xff,0x00,0x47,0x34,0x33,
0x39,0x48,0x38,0x41,0x37,0x31,0x34,0x4d,
0x4c,0x0a,0x00,0x00,0x00,0xfc,0x00,0x44,
0x45,0x4c,0x4c,0x20,0x31,0x39,0x30,0x38,
0x46,0x50,0x0a,0x20,0x00,0x00,0x00,0xfd,
0x00,0x38,0x4c,0x1f,0x53,0x0e,0x00,0x0a,
0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x7f,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
};

const uint8_t edid_samsung_tv[256]=
{
0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
0x4c,0x2d,0x59,0x06,0x00,0x00,0x00,0x00,
0x2d,0x13,0x01,0x03,0x80,0x10,0x09,0x78,
0x0a,0xee,0x91,0xa3,0x54,0x4c,0x99,0x26,
0x0f,0x50,0x54,0xbd,0xef,0x80,0x71,0x4f,
0x81,0x00,0x81,0x40,0x81,0x80,0x95,0x00,
0x95,0x0f,0xb3,0x00,0xa9,0x40,0x02,0x3a,
0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,
0x45,0x00,0xa0,0x5a,0x00,0x00,0x00,0x1e,
0x66,0x21,0x50,0xb0,0x51,0x00,0x1b,0x30,
0x40,0x70,0x36,0x00,0xa0,0x5a,0x00,0x00,
0x00,0x1e,0x00,0x00,0x00,0xfd,0x00,0x18,
0x4b,0x1a,0x51,0x17,0x00,0x0a,0x20,0x20,
0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xfc,
0x00,0x53,0x41,0x4d,0x53,0x55,0x4e,0x47,
0x0a,0x20,0x20,0x20,0x20,0x20,0x01,0x3a,
0x02,0x03,0x23,0xf1,0x4b,0x90,0x1f,0x04,
0x13,0x05,0x14,0x03,0x12,0x20,0x21,0x22,
0x23,0x09,0x07,0x07,0x83,0x01,0x00,0x00,
0xe2,0x00,0x0f,0x67,0x03,0x0c,0x00,0x30,
0x00,0xb8,0x2d,0x01,0x1d,0x00,0x72,0x51,
0xd0,0x1e,0x20,0x6e,0x28,0x55,0x00,0xa0,
0x5a,0x00,0x00,0x00,0x1e,0x01,0x1d,0x00,
0xbc,0x52,0xd0,0x1e,0x20,0xb8,0x28,0x55,
0x40,0xa0,0x5a,0x00,0x00,0x00,0x1e,0x01,
0x1d,0x80,0x18,0x71,0x1c,0x16,0x20,0x58,
0x2c,0x25,0x00,0xa0,0x5a,0x00,0x00,0x00,
0x9e,0x01,0x1d,0x80,0xd0,0x72,0x1c,0x16,
0x20,0x10,0x2c,0x25,0x80,0xa0,0x5a,0x00,
0x00,0x00,0x9e,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xed
};
*/
int hoi_drv_debug(void)
{
    int ret=0;
    t_hoi_msg_debug msg;

    //t_edid *edid1 = (t_edid *)edid_hp2710m;
    //t_edid *edid2 = (t_edid *)edid_sony_bravia;
    //t_edid *edid3 = (t_edid *)edid_dell_1908fp;
    //t_edid *edid4 = (t_edid *)edid_samsung_tv;
    t_edid edid;

    hoi_msg_debug_init(&msg);
    ret = hoi_msg(&msg);

    /*//edid_report_vid_timing(edid);
    report(DEBUG "HP2710M");
    edid_report(edid1);
    report(DEBUG "Sony Bravia");
    edid_report(edid2);
    report(DEBUG "Samsung TV");
    edid_report(edid4);
    report(DEBUG "Dell 1908FP");
    edid_report(edid3);
    report(DEBUG "Merge");
    edid_merge(edid1, edid2);
    edid_merge(edid1, edid4);
    //edid_merge(edid1, edid3);
    report(DEBUG "Output");
    edid_report(edid1);*/
    hoi_drv_rdedid(&edid);

    edid_write_file(&edid, "/tmp/edid_debug");
    edid_report(&edid);

    return ret;
}


int hoi_drv_set_timing(t_video_timing* timing)
{
    int ret=0;
    t_hoi_msg_image msg;
    
    memcpy(&msg.timing, timing, sizeof(t_video_timing));

    hoi_msg_set_timing_init(&msg);
    ret = hoi_msg(&msg);

    return ret;
}

int hoi_drv_getversion(t_hoic_getversion* cmd)
{
    int ret;
    t_hoi_msg_version msg;

    hoi_msg_getversion_init(&msg);
    ret = hoi_msg(&msg);
    cmd->fpga_date = msg.fpga_date;
    cmd->fpga_svn = msg.fpga_svn;
    cmd->sysid_date = msg.sysid_date;
    cmd->sysid_id = msg.sysid_id;
    cmd->sw_version = VERSION_SOFTWARE;
    strcpy(cmd->sw_tag, VERSION_TAG);

    return ret;
}

int hoi_drv_getusb(t_hoic_getusb* cmd)
{
    strcpy(cmd->device, "1-1.2"); //TODO: correct and variable device ID

    usb_get_dev(cmd->device);

    return 0;
}

//------------------------------------------------------------------------------
// EDID I/O

int hoi_drv_rdedid(void* buffer)
{
    int ret;
    t_hoi_msg_edid msg;

    hoi_msg_rdedid_init(&msg);
    ret = hoi_msg(&msg);
    memcpy(buffer, msg.edid, 256);

    return ret;
}

int hoi_drv_wredid(void* buffer)
{
    int ret;
    t_hoi_msg_edid msg;

    hoi_msg_wredid_init(&msg);
    memcpy(msg.edid, buffer, 256);
    ret = hoi_msg(&msg);

    return ret;
}


//------------------------------------------------------------------------------
// TAG I/O

int hoi_drv_rdvidtag(void* buffer, bool* available)
{
    int ret;
    t_hoi_msg_tag msg;

    hoi_msg_rdvidtag_init(&msg);
    ret = hoi_msg(&msg);
    memcpy(buffer, msg.tag, 256);
    *available = msg.available;

    return ret;
}

int hoi_drv_wrvidtag(void* buffer)
{
    int ret;
    t_hoi_msg_tag msg;

    hoi_msg_wrvidtag_init(&msg);
    memcpy(msg.tag, buffer, 256);
    ret = hoi_msg(&msg);

    return ret;
}

int hoi_drv_rdaudtag(void* buffer, bool* available)
{
    int ret;
    t_hoi_msg_tag msg;

    hoi_msg_rdaudtag_init(&msg);
    ret = hoi_msg(&msg);
    memcpy(buffer, msg.tag, 256);
    *available = msg.available;

    return ret;
}

int hoi_drv_wraudtag()
{
    int ret;
    t_hoi_msg_tag msg;

    hoi_msg_wraudtag_init(&msg);
    ret = hoi_msg(&msg);

    return ret;
}

//------------------------------------------------------------------------------
// HDCP
int hoi_drv_hdcp_get_timer(t_hoi_msg_hdcp_timer *msg)
{
    hoi_msg_hdcp_get_timer_init(msg);
    return hoi_msg(msg);
}

int hoi_drv_hdcp_set_timer(uint32_t start_time)
{
    t_hoi_msg_hdcp_timer msg;

    hoi_msg_hdcp_set_timer_init(&msg);
    msg.start_time = start_time;
    return hoi_msg(&msg);
}

int hoi_drv_hdcp_get_key(uint32_t key[4])
{
    int ret;
    t_hoi_msg_hdcp_key msg;

    hoi_msg_hdcp_get_key_init(&msg);
    ret = hoi_msg(&msg);

    key[0] = msg.key[0];
    key[1] = msg.key[1];
    key[2] = msg.key[2];
    key[3] = msg.key[3];

    return ret;
}

//------------------------------------------------------------------------------
// Watch dog
int hoi_drv_wdg_init(uint32_t service_time)
{
    t_hoi_msg_wdg msg;

    hoi_msg_wdg_init_init(&msg);
    msg.service_time = service_time;
    return hoi_msg(&msg);
}

//------------------------------------------------------------------------------
// command

#define HOI_CMDSW(T)                            \
    int hoi_drv_##T()                           \
    {                                           \
        t_hoi_msg msg;                          \
        hoi_msg_##T##_init(&msg);               \
        return hoi_msg(&msg);                   \
    }

HOI_CMDSW(poll);
HOI_CMDSW(loop);
HOI_CMDSW(osdon);
HOI_CMDSW(osdoff);
HOI_CMDSW(hpdon);
HOI_CMDSW(hpdoff);
HOI_CMDSW(repair);

HOI_CMDSW(hdcp_viden_eti);      //enable hdcp eti video encryption
HOI_CMDSW(hdcp_viden_eto);      //enable hdcp eto video encryption
HOI_CMDSW(hdcp_auden_eti);      //enable hdcp eti audio encryption
HOI_CMDSW(hdcp_auden_eto);      //enable hdcp eto audio encryption
HOI_CMDSW(hdcp_viddis_eti);     //disable hdcp eti video encryption
HOI_CMDSW(hdcp_viddis_eto);     //disable hdcp eto video encryption
HOI_CMDSW(hdcp_auddis_eti);     //disable hdcp eti audio encryption
HOI_CMDSW(hdcp_auddis_eto);     //disable hdcp eto audio encryption
HOI_CMDSW(hdcp_adv9889dis);  	//disable AD9889 hdcp encryption
HOI_CMDSW(hdcp_adv9889en);   	//enable AD9889 hdcp encryption

HOI_CMDSW(wdg_enable);
HOI_CMDSW(wdg_disable);
HOI_CMDSW(wdg_service);
HOI_CMDSW(hdcp_timer_enable);
HOI_CMDSW(hdcp_timer_disable);
HOI_CMDSW(hdcp_timer_load);
